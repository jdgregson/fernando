<!DOCTYPE html>
<html>
<head>
    <title>fernando</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, viewport-fit=cover">
    <meta name="theme-color" content="#252526">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" type="image/png" sizes="128x128" href="/static/icons/fernando-128.png">
    <link rel="apple-touch-icon" href="/static/icons/fernando-512.png">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.1.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.8.0/lib/xterm-addon-web-links.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.1.0/css/xterm.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; }
        html, body { height: 100%; overflow: hidden; background: #252526; }

        @supports (height: 100dvh) {
            html, body { height: 100dvh; background: #252526; }
        }
        body { font-family: monospace; background: #252526; color: #fff; display: flex; flex-direction: column; position: fixed; width: 100%; padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }

        .top-bar {
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .top-bar-title {
            font-size: 14px;
            font-weight: bold;
        }

        .top-bar button {
            background: #3465a3;
            border: none;
            color: #fff;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 0;
            font-size: 12px;
            font-family: monospace;
        }

        .top-bar button:hover {
            background: #4a7bc8;
        }

        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
            height: 100%;
            transition: transform 0.3s;
        }

        .sidebar-header {
            display: none;
        }

        .sidebar-toggle {
            display: none;
        }

        @media (max-width: 500px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: calc(28px + env(safe-area-inset-top));
                bottom: 0;
                z-index: 1002;
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }
        }

        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #3e3e42;
            font-size: 18px;
            font-weight: bold;
        }

        .session-list {
            flex: 1;
            overflow-y: auto;
        }

        .session-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-item:hover {
            background: #2a2d2e;
        }

        .session-item.active {
            background: #3465a3;
        }

        .session-name {
            flex: 1;
        }

        .close-btn {
            background: #c72e2e;
            border: none;
            color: white;
            padding: 0;
            cursor: pointer;
            border-radius: 3px;
            font-size: 16px;
            width: 24px;
            height: 24px;
            display: inline-block;
            text-align: center;
            line-height: 24px;
            vertical-align: middle;
        }

        .close-btn:hover {
            background: #e81123;
        }

        .session-item[data-session="desktop"] .close-btn {
            background: #d4a017;
            color: #fff;
            font-size: 18px;
        }

        .session-item[data-session="desktop"] .close-btn:hover {
            background: #f4c430;
        }

        .new-session {
            padding: 15px;
            border-top: 1px solid #3e3e42;
            background: #252526;
        }

        @supports (-webkit-touch-callout: none) {
            .new-session {
                padding-bottom: calc(65px + env(safe-area-inset-bottom));
            }
        }

        .new-session input {
            width: 100%;
            padding: 8px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #fff;
            margin-bottom: 8px;
        }

        .new-session button {
            width: 100%;
            padding: 8px;
            background: #3465a3;
            border: none;
            color: #fff;
            cursor: pointer;
            border-radius: 0;
            font-family: monospace;
            margin-bottom: 8px;
        }

        .new-session button:last-child {
            margin-bottom: 0;
        }

        .new-session button:hover {
            background: #4a7bc8;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
        }

        .modal.open {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #252526;
            padding: 20px;
            border: 1px solid #3e3e42;
            max-width: 400px;
            width: 90%;
        }

        .modal-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .modal-body button {
            width: 100%;
            padding: 10px;
            background: #3465a3;
            border: none;
            color: #fff;
            cursor: pointer;
            margin-bottom: 10px;
            font-family: monospace;
        }

        .modal-body button:hover {
            background: #4a7bc8;
        }

        .modal-close {
            background: #c72e2e !important;
            color: white !important;
            margin-top: 10px !important;
        }

        .modal-close:hover {
            background: #e81123 !important;
        }

        .session-cards {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .session-card {
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            padding: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .session-card:hover {
            background: #4e4e4e;
        }

        .session-card-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .session-card-desc {
            font-size: 12px;
            color: #ccc;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .terminals-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .terminal-container {
            flex: 1;
            position: relative;
            border-bottom: 1px solid #3e3e42;
            border: 2px solid transparent;
        }

        .terminal-container:last-child {
            border-bottom: none;
        }

        .terminal-container.hidden {
            display: none;
        }

        .terminal-container.active.split-mode {
            border: 2px solid #3465a3;
        }

        .terminal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .terminal .xterm {
            width: 100% !important;
            height: 100% !important;
        }

        .terminal .xterm .xterm-viewport {
            overflow-y: scroll !important;
            -webkit-overflow-scrolling: touch !important;
        }

        .browser-pane {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1e1e1e;
            pointer-events: auto;
        }

        .browser-pane.hidden {
            display: none;
        }

        .browser-pane iframe {
            width: 100%;
            height: 100%;
            border: none;
            touch-action: auto;
        }

        .pane-type-selector {
            display: none;
        }

        .split-controls {
            display: none;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #c72e2e;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(10px); }
        }

        .alert-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            align-items: center;
            justify-content: center;
        }

        .alert-modal.open {
            display: flex;
        }

        .alert-modal-content {
            background: #252526;
            border: 1px solid #3e3e42;
            max-width: 400px;
            width: 90%;
            padding: 20px;
        }

        .alert-modal-message {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .alert-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .alert-modal-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            cursor: pointer;
            font-family: monospace;
            background: #3465a3;
            color: #fff;
        }

        .alert-modal-buttons button:hover {
            background: #4a7bc8;
        }

        .alert-modal-buttons button.cancel {
            background: #c72e2e;
            color: white;
        }

        .alert-modal-buttons button.cancel:hover {
            background: #e81123;
        }

        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            border: 1.5px solid #eee;
            border-radius: 50px;
            padding: 8px 12px;
            z-index: 999;
            gap: 6px;
            justify-content: center;
            margin-bottom: calc(10px + env(safe-area-inset-bottom));
        }

        @media (max-width: 500px) {
            .mobile-controls {
                display: flex;
            }

            .terminals-wrapper {
                padding-bottom: 20px;
            }
        }

        .mobile-controls button {
            background: transparent;
            border: none;
            color: #fff;
            padding: 8px 10px;
            font-size: 13px;
            font-family: monospace;
            border-radius: 8px;
            min-width: 42px;
            cursor: pointer;
        }

        .mobile-controls button:active {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="top-bar-left">
            <button class="sidebar-toggle" onclick="toggleSidebar()">☰</button>
            <span class="top-bar-title">fernando</span>
        </div>
        <div>
            <button onclick="toggleSplit()">Split</button>
        </div>
    </div>
    <div class="content-wrapper">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">fernando</div>
            <div class="session-list" id="sessionList">
                <div class="session-item" data-session="desktop">
                    <span class="session-name">Desktop</span>
                    <button class="close-btn" onclick="event.stopPropagation(); restartDesktop()">↻</button>
                </div>
                {% for session in sessions %}
                <div class="session-item" data-session="{{ session }}">
                    <span class="session-name">{{ session }}</span>
                    <button class="close-btn" onclick="closeSession(event, '{{ session }}')">✕</button>
                </div>
                {% endfor %}
            </div>
            <div class="new-session">
                <button onclick="openNewSessionModal()">New Session</button>
                <button onclick="openSubagentsModal()">Subagents</button>
            </div>
        </div>

        <div class="main-content">
            <div class="terminals-wrapper">
                <div class="terminal-container active" id="terminal1-container">
                    <div class="terminal" id="terminal1"></div>
                    <div class="browser-pane hidden" id="browser1"></div>
                </div>
                <div class="terminal-container hidden" id="terminal2-container">
                    <div class="terminal" id="terminal2"></div>
                    <div class="browser-pane hidden" id="browser2"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="newSessionModal" onclick="closeNewSessionModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">New Session</div>
            <div class="modal-body">
                <div class="session-cards">
                    <div class="session-card" onclick="createSessionType('shell')">
                        <div class="session-card-title">Shell</div>
                        <div class="session-card-desc">Standard bash shell</div>
                    </div>
                    <div class="session-card" onclick="createSessionType('kiro')">
                        <div class="session-card-title">Kiro</div>
                        <div class="session-card-desc">Kiro CLI interactive mode</div>
                    </div>
                    <div class="session-card" onclick="createSessionType('kiro-unchained')">
                        <div class="session-card-title">Kiro Unchained</div>
                        <div class="session-card-desc">Kiro CLI chat agent mode</div>
                    </div>
                </div>
                <button class="modal-close" onclick="closeNewSessionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="subagentsModal" onclick="closeSubagentsModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">Scheduled Subagents</div>
            <div class="modal-body">
                <button onclick="openNewSubagentModal()">New Subagent</button>
                <button onclick="showSchedules()">View Schedules</button>
                <div id="subagentsList" style="margin-top: 15px; max-height: 400px; overflow-y: auto;"></div>
                <button class="modal-close" onclick="closeSubagentsModal()">Close</button>
            </div>
        </div>
    </div>

    <div class="modal" id="schedulesModal" onclick="closeSchedulesModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">Active Schedules</div>
            <div class="modal-body">
                <h3 style="margin-top: 0;">One-time (at)</h3>
                <div id="atJobsList" style="margin-bottom: 20px;"></div>
                
                <h3>Recurring (cron)</h3>
                <div id="cronJobsList" style="margin-bottom: 20px;"></div>
                
                <button class="modal-close" onclick="closeSchedulesModal()">Close</button>
            </div>
        </div>
    </div>

    <div class="modal" id="newSubagentModal" onclick="closeNewSubagentModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">Create Subagent</div>
            <div class="modal-body">
                <label>Task ID:</label>
                <input type="text" id="subagentTaskId" placeholder="e.g., research-aws-pricing" style="width: 100%; margin-bottom: 10px;">
                
                <label>Task Description:</label>
                <textarea id="subagentTask" placeholder="Describe the task..." style="width: 100%; height: 100px; margin-bottom: 10px;"></textarea>
                
                <label>Context File Path (optional):</label>
                <input type="text" id="subagentContextPath" placeholder="/path/to/context.txt" style="width: 100%; margin-bottom: 10px;">
                <div style="font-size: 11px; color: #888; margin-bottom: 10px;">File will be created if it doesn't exist. Subagent will read and append to it.</div>
                
                <label>Schedule (optional):</label>
                <select id="subagentScheduleType" onchange="updateScheduleInput()" style="width: 100%; margin-bottom: 10px;">
                    <option value="">Run immediately</option>
                    <option value="at">At specific time</option>
                    <option value="every">Recurring</option>
                </select>
                
                <div id="scheduleInputContainer"></div>
                
                <button class="modal-close" onclick="closeNewSubagentModal()">Cancel</button>
                <button onclick="createSubagent()">Create</button>
            </div>
        </div>
    </div>

    <div class="mobile-controls">
        <button onmousedown="event.preventDefault(); sendKey('\x03')">^C</button>
        <button onmousedown="event.preventDefault(); sendKey('\x1b')">ESC</button>
        <button onmousedown="event.preventDefault(); sendKey('\t')">TAB</button>
        <button onmousedown="event.preventDefault(); sendKey('\x1b[D')">←</button>
        <button onmousedown="event.preventDefault(); sendKey('\x1b[A')">↑</button>
        <button onmousedown="event.preventDefault(); sendKey('\x1b[B')">↓</button>
        <button onmousedown="event.preventDefault(); sendKey('\x1b[C')">→</button>
    </div>

    <div class="alert-modal" id="alertModal">
        <div class="alert-modal-content">
            <div class="alert-modal-message" id="alertMessage"></div>
            <div class="alert-modal-buttons" id="alertButtons"></div>
        </div>
    </div>
</body>
</html>

    <script>
        function showAlert(message) {
            return new Promise(resolve => {
                document.getElementById('alertMessage').textContent = message;
                document.getElementById('alertButtons').innerHTML = '<button onclick="closeAlert()">OK</button>';
                document.getElementById('alertModal').classList.add('open');
                window.alertResolve = resolve;
            });
        }

        function showConfirm(message) {
            return new Promise(resolve => {
                document.getElementById('alertMessage').textContent = message;
                document.getElementById('alertButtons').innerHTML =
                    '<button class="cancel" onclick="closeAlert(false)">Cancel</button><button onclick="closeAlert(true)">OK</button>';
                document.getElementById('alertModal').classList.add('open');
                window.alertResolve = resolve;
            });
        }

        function closeAlert(result) {
            document.getElementById('alertModal').classList.remove('open');
            if (window.alertResolve) {
                window.alertResolve(result);
                window.alertResolve = null;
            }
        }
        const socket = io({
            path: window.location.pathname.replace(/\/$/, '') + '/socket.io',
            query: { api_key: '{{ api_key }}' },
            reconnection: true,
            reconnectionDelay: 500,
            reconnectionAttempts: 10
        });

        let csrfToken = null;
        let isSplit = false;
        let activeTerminal = 1;
        let paneTypes = { 1: 'terminal', 2: 'terminal' };
        let desktopMode = false;
        let isReconnecting = false;

        socket.on('connected', (data) => {
            csrfToken = data.csrf_token;
            console.log('Connected with CSRF token');
        });

        // Helper to add CSRF token to emit data
        function emitWithCsrf(event, data = {}) {
            socket.emit(event, { ...data, csrf_token: csrfToken });
        }

        // Handle iOS backgrounding/foregrounding
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('App foregrounded, reconnecting...');
                handleForeground();
            }
        });

        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                console.log('Page restored from cache, reconnecting...');
                handleForeground();
            }
        });

        function handleForeground() {
            // Reconnect socket if disconnected
            if (!socket.connected) {
                socket.connect();
            }

            // Reattach sessions
            if (currentSession1 && paneTypes[1] === 'terminal') {
                setTimeout(() => {
                    term1.clear();
                    emitWithCsrf('attach_session', { terminal: 1, session: currentSession1 });
                    setTimeout(doFit, 100);
                }, 200);
            }

            if (currentSession2 && paneTypes[2] === 'terminal' && isSplit) {
                setTimeout(() => {
                    term2.clear();
                    emitWithCsrf('attach_session', { terminal: 2, session: currentSession2 });
                    setTimeout(doFit, 100);
                }, 200);
            }

            // Reload browser iframes
            reloadBrowserPanes();
        }

        function reloadBrowserPanes() {
            [1, 2].forEach(paneNum => {
                if (paneTypes[paneNum] === 'browser') {
                    const browser = document.getElementById(`browser${paneNum}`);
                    const iframe = browser.querySelector('iframe');
                    if (iframe) {
                        console.log(`Reloading browser pane ${paneNum}`);
                        iframe.src = iframe.src; // Force reload
                    }
                }
            });
        }

        socket.on('reconnect', () => {
            console.log('Socket reconnected');
            handleForeground();
        });

        const term1 = new Terminal({
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            theme: { background: '#1e1e1e' },
            scrollback: 10000,
            allowTransparency: false
        });

        const term2 = new Terminal({
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            theme: { background: '#1e1e1e' },
            scrollback: 10000,
            allowTransparency: false
        });

        term1.open(document.getElementById('terminal1'));
        term2.open(document.getElementById('terminal2'));

        // iOS touch scrolling - send tmux scroll commands
        setTimeout(() => {
            document.querySelectorAll('.xterm').forEach((xtermEl, idx) => {
                const term = idx === 0 ? term1 : term2;
                const termNum = idx + 1;
                let startY = 0;
                let lastY = 0;
                let lastTime = 0;
                let isScrolling = false;
                let hasMoved = false;
                let keyboardOpen = false;

                // Track keyboard state
                const textarea = xtermEl.querySelector('.xterm-helper-textarea');
                if (textarea) {
                    textarea.addEventListener('focus', () => {
                        // Always try to exit copy mode, then backspace the 'q' if not in copy mode
                        emitWithCsrf('input', { terminal: termNum, data: 'q\x7f' }); // q + backspace
                        isScrolling = false;
                        keyboardOpen = true;
                        // Scroll based on xterm viewport scroll position
                        setTimeout(() => {
                            const term = termNum === 1 ? term1 : term2;
                            const viewport = xtermEl.querySelector('.xterm-viewport');
                            if (viewport) {
                                const scrollTop = viewport.scrollTop;
                                const scrollHeight = viewport.scrollHeight;
                                const clientHeight = viewport.clientHeight;

                                if (isSplit) {
                                    // For split, use ratio-based scroll
                                    const scrollRatio = scrollTop / (scrollHeight - clientHeight);
                                    const container = document.getElementById(`terminal${termNum}-container`);
                                    const containerHeight = container.offsetHeight;
                                    const scrollAmount = scrollRatio * containerHeight + 20;
                                    window.scrollBy({ top: scrollAmount, behavior: 'smooth' });
                                } else {
                                    // For single pane, scroll to bottom if near bottom
                                    if (scrollTop + clientHeight >= scrollHeight - 50) {
                                        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                                    }
                                }
                            }
                        }, 300);
                    });
                    textarea.addEventListener('blur', () => {
                        keyboardOpen = false;
                    });
                }

                xtermEl.addEventListener('touchstart', (e) => {
                    if (e.target.tagName === 'TEXTAREA' || keyboardOpen) return;

                    startY = lastY = e.touches[0].clientY;
                    lastTime = Date.now();
                    hasMoved = false;
                    isScrolling = false;
                }, { passive: false });

                xtermEl.addEventListener('touchmove', (e) => {
                    if (e.target.tagName === 'TEXTAREA' || keyboardOpen) return;

                    e.preventDefault();
                    e.stopPropagation();
                    const currentY = e.touches[0].clientY;
                    const currentTime = Date.now();
                    const deltaY = lastY - currentY;
                    const deltaTime = Math.max(1, currentTime - lastTime);
                    const velocity = Math.abs(deltaY) / deltaTime;

                    if (Math.abs(startY - currentY) > 10) {
                        hasMoved = true;
                    }

                    lastY = currentY;
                    lastTime = currentTime;

                    if (!isScrolling && hasMoved) {
                        emitWithCsrf('input', { terminal: termNum, data: '\x02[' });
                        isScrolling = true;
                    }

                    if (isScrolling && Math.abs(deltaY) > 0.5) {
                        const multiplier = Math.min(3, 1 + velocity * 2);
                        const lines = Math.max(1, Math.round(Math.abs(deltaY) * multiplier / 3));
                        const key = deltaY > 0 ? '\x1b[B' : '\x1b[A';
                        for (let i = 0; i < lines; i++) {
                            emitWithCsrf('input', { terminal: termNum, data: key });
                        }
                    }
                }, { passive: false });

                xtermEl.addEventListener('touchend', (e) => {
                    if (e.target.tagName === 'TEXTAREA' || keyboardOpen) return;

                    if (isScrolling) {
                        emitWithCsrf('input', { terminal: termNum, data: 'q' });
                        isScrolling = false;
                    }
                }, { passive: false });
            });
        }, 100);

        console.log('Terminals opened');
        console.log('Terminal1 element:', document.getElementById('terminal1'));
        console.log('Terminal2 element:', document.getElementById('terminal2'));

        const fitAddon1 = new FitAddon.FitAddon();
        const fitAddon2 = new FitAddon.FitAddon();
        const webLinksAddon1 = new WebLinksAddon.WebLinksAddon();
        const webLinksAddon2 = new WebLinksAddon.WebLinksAddon();
        term1.loadAddon(fitAddon1);
        term1.loadAddon(webLinksAddon1);
        term2.loadAddon(fitAddon2);
        term2.loadAddon(webLinksAddon2);

        console.log('Fit addons loaded');

        function toggleDesktop() {
            const activePane = activeTerminal;
            const browser = document.getElementById(`browser${activePane}`);
            const terminal = document.getElementById(`terminal${activePane}`);

            if (paneTypes[activePane] === 'terminal') {
                paneTypes[activePane] = 'browser';
                terminal.classList.add('hidden');
                browser.classList.remove('hidden');

                // Clear session tracking when switching to browser
                if (activePane === 1) {
                    currentSession1 = null;
                } else {
                    currentSession2 = null;
                }

                // Remove existing iframe and create fresh one
                browser.innerHTML = '';
                const iframe = document.createElement('iframe');
                iframe.src = '/kasm/?resize=remote';
                iframe.allow = 'autoplay; clipboard-read; clipboard-write';
                iframe.setAttribute('allowfullscreen', '');
                iframe.setAttribute('webkitallowfullscreen', '');
                iframe.setAttribute('mozallowfullscreen', '');
                browser.appendChild(iframe);
            } else {
                paneTypes[activePane] = 'terminal';
                terminal.classList.remove('hidden');
                browser.classList.add('hidden');
                setTimeout(doFit, 100);
            }
        }

        function setPaneType(paneNum, type) {
            paneTypes[paneNum] = type;
            const container = document.getElementById(`terminal${paneNum}-container`);
            const terminal = document.getElementById(`terminal${paneNum}`);
            const browser = document.getElementById(`browser${paneNum}`);
            const buttons = container.querySelectorAll('.pane-type-selector button');

            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            if (type === 'terminal') {
                terminal.classList.remove('hidden');
                browser.classList.add('hidden');
                setTimeout(doFit, 100);
            } else {
                terminal.classList.add('hidden');
                browser.classList.remove('hidden');
                if (!browser.querySelector('iframe')) {
                    browser.innerHTML = '<iframe src="/kasm/?resize=remote"></iframe>';
                }
            }
        }

        function doFit() {
            console.log('doFit called');
            if (paneTypes[1] === 'terminal') {
                fitAddon1.fit();
                console.log('Term1 fitted:', term1.rows, term1.cols);
                emitWithCsrf('resize', { terminal: 1, rows: term1.rows, cols: term1.cols });
            }
            if (isSplit && paneTypes[2] === 'terminal') {
                fitAddon2.fit();
                console.log('Term2 fitted:', term2.rows, term2.cols);
                emitWithCsrf('resize', { terminal: 2, rows: term2.rows, cols: term2.cols });
            }
        }

        let currentSession1 = null;
        let currentSession2 = null;

        term1.onData(data => {
            emitWithCsrf('input', { terminal: 1, data: data });
        });

        term2.onData(data => {
            emitWithCsrf('input', { terminal: 2, data: data });
        });

        socket.on('output', data => {
            console.log('Received output for terminal', data.terminal, 'length:', data.data.length);
            if (data.terminal === 1) {
                term1.write(data.data);
            } else if (data.terminal === 2) {
                term2.write(data.data);
            }
        });

        socket.on('sessions_list', data => {
            updateSessionList(data.sessions);
        });

        function updateSessionList(sessions) {
            const sessionList = document.getElementById('sessionList');
            const currentSessions = Array.from(sessionList.querySelectorAll('.session-item')).map(el => el.dataset.session).filter(s => s !== 'desktop');

            // Check if lists are different
            if (JSON.stringify(currentSessions.sort()) === JSON.stringify(sessions.sort())) {
                return;
            }

            sessionList.innerHTML = '';
            
            // Add Desktop item first
            const desktopItem = document.createElement('div');
            desktopItem.className = 'session-item';
            desktopItem.dataset.session = 'desktop';
            
            const desktopName = document.createElement('span');
            desktopName.className = 'session-name';
            desktopName.textContent = 'Desktop';
            
            const restartBtn = document.createElement('button');
            restartBtn.className = 'close-btn';
            restartBtn.textContent = '↻';
            restartBtn.onclick = (e) => { e.stopPropagation(); restartDesktop(); };
            
            desktopItem.appendChild(desktopName);
            desktopItem.appendChild(restartBtn);
            desktopItem.addEventListener('click', function() {
                toggleDesktop();
                if (window.innerWidth <= 500) {
                    document.getElementById('sidebar').classList.remove('open');
                }
            });
            sessionList.appendChild(desktopItem);
            
            sessions.forEach(session => {
                const item = document.createElement('div');
                item.className = 'session-item';
                item.dataset.session = session;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'session-name';
                nameSpan.textContent = session;

                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-btn';
                closeBtn.textContent = '✕';
                closeBtn.onclick = (e) => closeSession(e, session);

                item.appendChild(nameSpan);
                item.appendChild(closeBtn);

                item.addEventListener('click', function() {
                    attachSession(this.dataset.session);
                    if (window.innerWidth <= 500) {
                        document.getElementById('sidebar').classList.remove('open');
                    }
                });
                sessionList.appendChild(item);
            });

            // Auto-attach if no session attached
            if (!currentSession1 && sessions.length > 0) {
                attachSession(sessions[0]);
            }
        }

        // Poll for session updates every 2 seconds
        setInterval(() => {
            emitWithCsrf('get_sessions');
        }, 2000);

        socket.on('session_created', data => {
            emitWithCsrf('get_sessions');
        });

        socket.on('session_closed', data => {
            emitWithCsrf('get_sessions');
        });

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function attachSession(sessionName) {
            console.log('Attaching session:', sessionName, 'to terminal:', activeTerminal);

            // If browser is showing, switch to terminal first
            if (paneTypes[activeTerminal] === 'browser') {
                toggleDesktop();
            }

            if (activeTerminal === 1 && currentSession2 === sessionName) {
                showToast('Session already attached to Terminal 2');
                return;
            } else if (activeTerminal === 2 && currentSession1 === sessionName) {
                showToast('Session already attached to Terminal 1');
                return;
            }

            const term = activeTerminal === 1 ? term1 : term2;
            term.clear();

            if (activeTerminal === 1) {
                currentSession1 = sessionName;
            } else {
                currentSession2 = sessionName;
            }

            emitWithCsrf('attach_session', { terminal: activeTerminal, session: sessionName });
            console.log('Emitted attach_session');

            term.focus();
            setTimeout(doFit, 100);
        }

        function toggleSplit() {
            isSplit = !isSplit;
            const container2 = document.getElementById('terminal2-container');

            if (isSplit) {
                container2.classList.remove('hidden');
                setActiveTerminal(2);
            } else {
                container2.classList.add('hidden');
                setActiveTerminal(1);
            }

            setTimeout(doFit, 100);
        }

        function setActiveTerminal(termNum) {
            console.log('Setting active terminal to:', termNum);
            activeTerminal = termNum;
            const term1Container = document.getElementById('terminal1-container');
            const term2Container = document.getElementById('terminal2-container');

            term1Container.classList.toggle('active', termNum === 1);
            term2Container.classList.toggle('active', termNum === 2);

            // Add split-mode class to both when split
            if (isSplit) {
                term1Container.classList.add('split-mode');
                term2Container.classList.add('split-mode');
            } else {
                term1Container.classList.remove('split-mode');
                term2Container.classList.remove('split-mode');
            }
        }

        // Click handlers to switch active terminal
        document.getElementById('terminal1-container').addEventListener('click', (e) => {
            console.log('Terminal 1 clicked');
            setActiveTerminal(1);
            if (window.innerWidth <= 500) {
                document.getElementById('sidebar').classList.remove('open');
            }
            e.stopPropagation();
        });

        document.getElementById('terminal2-container').addEventListener('click', (e) => {
            console.log('Terminal 2 clicked');
            if (isSplit) {
                setActiveTerminal(2);
            }
            if (window.innerWidth <= 500) {
                document.getElementById('sidebar').classList.remove('open');
            }
            e.stopPropagation();
        });

        function openNewSessionModal() {
            document.getElementById('newSessionModal').classList.add('open');
            if (window.innerWidth <= 500) {
                document.getElementById('sidebar').classList.remove('open');
            }
        }

        function closeNewSessionModal() {
            document.getElementById('newSessionModal').classList.remove('open');
        }

        function createSessionType(type) {
            emitWithCsrf('create_session', { type: type });
            closeNewSessionModal();
        }

        function closeSession(event, sessionName) {
            event.stopPropagation();
            showConfirm(`Close session "${sessionName}"?`).then(result => {
                if (result) {
                    emitWithCsrf('close_session', { session: sessionName });
                }
            });
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
        }

        function openSubagentsModal() {
            document.getElementById('subagentsModal').classList.add('open');
            if (window.innerWidth <= 500) {
                document.getElementById('sidebar').classList.remove('open');
            }
            loadSubagents();
        }

        function closeSubagentsModal() {
            document.getElementById('subagentsModal').classList.remove('open');
        }

        function openNewSubagentModal() {
            document.getElementById('newSubagentModal').classList.add('open');
        }

        function closeNewSubagentModal() {
            document.getElementById('newSubagentModal').classList.remove('open');
        }

        function updateScheduleInput() {
            const type = document.getElementById('subagentScheduleType').value;
            const container = document.getElementById('scheduleInputContainer');
            
            if (type === 'at') {
                container.innerHTML = '<input type="time" id="scheduleTime" style="width: 100%; margin-bottom: 10px;">';
            } else if (type === 'every') {
                container.innerHTML = `
                    <select id="scheduleInterval" style="width: 100%; margin-bottom: 10px;">
                        <option value="minute">Every minute</option>
                        <option value="5 minutes">Every 5 minutes</option>
                        <option value="10 minutes">Every 10 minutes</option>
                        <option value="15 minutes">Every 15 minutes</option>
                        <option value="30 minutes">Every 30 minutes</option>
                        <option value="hour">Every hour</option>
                        <option value="day">Every day</option>
                        <option value="week">Every week</option>
                    </select>
                `;
            } else {
                container.innerHTML = '';
            }
        }

        async function loadSubagents() {
            emitWithCsrf('list_subagents');
        }

        socket.on('subagents_list', (data) => {
            const subagents = data.subagents;
            const list = document.getElementById('subagentsList');
            
            if (subagents.length === 0) {
                list.innerHTML = '<p style="color: #888;">No subagents yet</p>';
                return;
            }
            
            list.innerHTML = subagents.map(s => `
                <div style="border: 1px solid #3e3e42; padding: 10px; margin-bottom: 10px; border-radius: 3px;">
                    <div style="font-weight: bold;">${s.task_id}</div>
                    <div style="font-size: 12px; color: #888; margin: 5px 0;">${s.task}</div>
                    <div style="font-size: 11px; color: #888;">Status: ${s.status} (${s.progress}%)</div>
                    ${s.schedule ? `<div style="font-size: 11px; color: #3465a3;">Schedule: ${s.schedule}</div>` : ''}
                    <div style="font-size: 11px; color: #888;">${s.current_step}</div>
                    <div style="margin-top: 5px;">
                        <button onclick="viewSubagent('${s.task_id}')" style="font-size: 11px; padding: 3px 8px;">View</button>
                        <button onclick="terminateSubagent('${s.task_id}')" style="font-size: 11px; padding: 3px 8px;">Terminate</button>
                        <button onclick="deleteSubagent('${s.task_id}')" style="font-size: 11px; padding: 3px 8px;">Delete</button>
                    </div>
                </div>
            `).join('');
        });

        function createSubagent() {
            const taskId = document.getElementById('subagentTaskId').value;
            const task = document.getElementById('subagentTask').value;
            const contextPath = document.getElementById('subagentContextPath').value;
            const scheduleType = document.getElementById('subagentScheduleType').value;
            
            if (!taskId || !task) {
                showAlert('Task ID and Task are required');
                return;
            }
            
            let schedule = null;
            if (scheduleType === 'at') {
                const time = document.getElementById('scheduleTime').value;
                if (time) schedule = `at ${time}`;
            } else if (scheduleType === 'every') {
                const interval = document.getElementById('scheduleInterval').value;
                schedule = `every ${interval}`;
            }
            
            emitWithCsrf('create_subagent', {
                task_id: taskId,
                task: task,
                context_path: contextPath || null,
                schedule: schedule
            });
        }

        socket.on('subagent_created', (data) => {
            showAlert('Subagent created successfully');
            closeNewSubagentModal();
            loadSubagents();
            document.getElementById('subagentTaskId').value = '';
            document.getElementById('subagentTask').value = '';
            document.getElementById('subagentContextPath').value = '';
            document.getElementById('subagentScheduleType').value = '';
            updateScheduleInput();
        });

        socket.on('subagent_error', (data) => {
            showAlert('Failed to create subagent: ' + data.error);
        });

        function viewSubagent(taskId) {
            emitWithCsrf('get_subagent_status', { task_id: taskId });
        }

        socket.on('subagent_status', (data) => {
            showAlert(JSON.stringify(data, null, 2));
        });

        async function terminateSubagent(taskId) {
            const result = await showConfirm(`Terminate subagent ${taskId}?`);
            if (result) {
                emitWithCsrf('terminate_subagent', { task_id: taskId });
            }
        }

        socket.on('subagent_terminated', (data) => {
            showAlert('Subagent terminated');
            loadSubagents();
        });

        async function deleteSubagent(taskId) {
            const result = await showConfirm(`Delete subagent ${taskId}? This will remove all data.`);
            if (result) {
                emitWithCsrf('delete_subagent', { task_id: taskId });
            }
        }

        socket.on('subagent_deleted', (data) => {
            showAlert('Subagent deleted');
            loadSubagents();
        });

        function closeSchedulesModal() {
            document.getElementById('schedulesModal').classList.remove('open');
        }

        function showSchedules() {
            document.getElementById('schedulesModal').classList.add('open');
            emitWithCsrf('get_at_jobs');
            emitWithCsrf('get_cron_jobs');
        }

        socket.on('at_jobs', (data) => {
            const atJobs = data.jobs;
            const atList = document.getElementById('atJobsList');
            
            if (atJobs.length === 0) {
                atList.innerHTML = '<p style="color: #888;">No scheduled one-time jobs</p>';
            } else {
                atList.innerHTML = atJobs.map(job => `
                    <div style="border: 1px solid #3e3e42; padding: 8px; margin-bottom: 8px; border-radius: 3px;">
                        <div style="font-size: 12px;">Job ${job.job_id}: ${job.scheduled_time}</div>
                        <button onclick="removeAtJob('${job.job_id}')" style="font-size: 11px; padding: 3px 8px; margin-top: 5px;">Remove</button>
                    </div>
                `).join('');
            }
        });

        socket.on('cron_jobs', (data) => {
            const cronJobs = data.jobs;
            const cronList = document.getElementById('cronJobsList');
            
            if (cronJobs.length === 0) {
                cronList.innerHTML = '<p style="color: #888;">No recurring jobs</p>';
            } else {
                cronList.innerHTML = cronJobs.map(job => `
                    <div style="border: 1px solid #3e3e42; padding: 8px; margin-bottom: 8px; border-radius: 3px;">
                        <div style="font-size: 12px; font-weight: bold;">${job.task_id || 'Unknown task'}</div>
                        <div style="font-size: 11px; color: #888; margin: 3px 0;">Schedule: ${job.cron_time}</div>
                        <div style="font-size: 10px; color: #666; word-break: break-all;">${job.command}</div>
                        ${job.task_id ? `<button onclick="removeCronJob('${job.task_id}')" style="font-size: 11px; padding: 3px 8px; margin-top: 5px;">Remove</button>` : ''}
                    </div>
                `).join('');
            }
        });

        async function removeAtJob(jobId) {
            const result = await showConfirm(`Remove scheduled job ${jobId}?`);
            if (result) {
                emitWithCsrf('remove_at_job', { job_id: jobId });
            }
        }

        socket.on('at_job_removed', (data) => {
            showAlert('Job removed');
            showSchedules();
        });

        async function removeCronJob(taskId) {
            const result = await showConfirm(`Remove recurring job for ${taskId}?`);
            if (result) {
                emitWithCsrf('remove_cron_job', { task_id: taskId });
            }
        }

        socket.on('cron_job_removed', (data) => {
            showAlert('Job removed');
            showSchedules();
        });

        socket.on('desktop_restart_error', (data) => {
            showAlert('Error: ' + data.error);
        });

        // Click handler for session items
        document.querySelectorAll('.session-item').forEach(item => {
            item.addEventListener('click', function() {
                const sessionName = this.dataset.session;
                if (sessionName === 'desktop') {
                    toggleDesktop();
                } else {
                    attachSession(sessionName);
                }
                // Close sidebar on mobile after selection
                if (window.innerWidth <= 500) {
                    document.getElementById('sidebar').classList.remove('open');
                }
            });
        });

        // Auto-attach to first session if exists, or open modal if no sessions
        const firstSession = document.querySelector('.session-item[data-session]:not([data-session="desktop"])');
        if (firstSession) {
            attachSession(firstSession.dataset.session);
        } else {
            openNewSessionModal();
        }

        // Request initial session list
        emitWithCsrf('get_sessions');

        // Fit on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(doFit, 100);
        });

        // Force initial fit multiple times to ensure it works
        setTimeout(doFit, 100);
        setTimeout(doFit, 300);
        setTimeout(doFit, 500);
        setTimeout(doFit, 1000);

        function sendKey(key) {
            emitWithCsrf('input', { terminal: activeTerminal, data: key });
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 500) {
                const sidebar = document.getElementById('sidebar');
                const sidebarToggle = document.querySelector('.sidebar-toggle');
                if (sidebar.classList.contains('open') &&
                    !sidebar.contains(e.target) &&
                    e.target !== sidebarToggle) {
                    sidebar.classList.remove('open');
                }
            }
        });

        // Reposition mobile controls above keyboard
        if (window.visualViewport) {
            const mobileControls = document.querySelector('.mobile-controls');
            let keyboardVisible = false;

            const updatePosition = () => {
                const vpHeight = window.visualViewport.height;
                const vpOffsetTop = window.visualViewport.offsetTop;
                const windowHeight = window.innerHeight;

                // Check if keyboard is visible
                keyboardVisible = vpHeight < windowHeight - 100;

                if (keyboardVisible) {
                    mobileControls.style.display = 'flex';
                    mobileControls.style.bottom = 'auto';
                    mobileControls.style.top = (vpOffsetTop + vpHeight - mobileControls.offsetHeight) + 'px';
                } else {
                    mobileControls.style.display = 'none';
                }
            };

            const updatePositionOnly = () => {
                if (keyboardVisible) {
                    const vpHeight = window.visualViewport.height;
                    const vpOffsetTop = window.visualViewport.offsetTop;
                    mobileControls.style.top = (vpOffsetTop + vpHeight - mobileControls.offsetHeight) + 'px';
                }
            };

            window.visualViewport.addEventListener('resize', updatePosition);
            window.visualViewport.addEventListener('scroll', updatePositionOnly);
        }
    </script>
</body>
</html>
